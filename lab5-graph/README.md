## Алгоритм Пріма

**Опис:**  
Алгоритм Пріма будує мінімальне кістякове дерево (**MST**) шляхом поступового розширення однієї зв’язної компоненти.  
На кожному кроці вибирається **мінімальне ребро**, яке з’єднує поточне дерево з новою вершиною.

**Характеристики:**
- **Складність:**  
  - Кращий випадок: O(E log V)  
  - Середній випадок: O(E log V)  
  - Гірший випадок: O(E log V)  
- **Пам’ять:** O(V)  
- **Стабільність:** ✔ Завжди дає одне з мінімальних дерев  
- Найкраще працює для **щільних графів** (багато ребер)

**Приклад запуску `Prim.java`:**  
<img width="259" height="165" alt="image" src="https://github.com/user-attachments/assets/53e2557a-3f83-41e9-b742-50dfa2c565d8" />




---

## Алгоритм Крускала

**Опис:**  
Алгоритм Крускала будує MST через об’єднання компонент зв’язності.  
Ребра сортуються за вагою, після чого найменші додаються в дерево, **якщо не утворюють циклу**  
(перевірка виконується за допомогою структури *Disjoint Set Union* — DSU).

**Характеристики:**
- **Складність:**  
  - Кращий випадок: O(E log E)  
  - Середній випадок: O(E log E)  
  - Гірший випадок: O(E log E)  
- **Пам’ять:** O(V)  
- **Стабільність:** ✔ Дає мінімальне дерево (може бути кілька еквівалентних варіантів)  
- Ефективний для **розріджених графів**

**Приклад запуску `Kruskal.java`:**

<img width="303" height="175" alt="image" src="https://github.com/user-attachments/assets/556a71c9-94ed-492f-91b2-a17efd360955" />


---

## Результати

Для графа варіанта №10 обидва алгоритми побудували однакове МКД:

**Ребра МКД:**  
